#!/usr/bin/env bash
: ${KUBASH_DIR:=$HOME/.kubash}
: ${KUBASH_BIN:=$KUBASH_DIR/bin}
: ${KUBASH_HOSTS_CSV:=$KUBASH_DIR/hosts.csv}
: ${KUBASH_HOSTS:=$KUBASH_DIR/hosts}
: ${VERBOSITY:=0}
: ${KVM_IMAGE_DIR:=/var/lib/libvirt/images}
: ${KUBASH_BUILDS_TMP:=$KVM_IMAGE_DIR/kubashtmp}
: ${KUBASH_BUILDS:=$KVM_IMAGE_DIR/kubashbuilds}
: ${KVM_BASE_IMG:=kubash.qcow2}
: ${KVM_RAM:=4096}
: ${KVM_CPU:=2}
: ${KVM_NET:='default'}
: ${PSEUDO:=sudo}
: ${K8S_user:=root}
: ${K8S_NET:=calico}
: ${K8S_node_port:=22}
: ${K8S_su_user:=coopadmin}
: ${my_DOMAIN:=example.com}
: ${GOPATH:=~/.go}
: ${KUTIME:="/usr/bin/time -v"}
: ${PARALLEL_JOBS:=1}
: ${PARALLEL:="parallel"}

# Rasion d'etre
RAISON=false

# global vars
ANSWER_YES=no

# prep the columns strings for csv input
hosts_csv_columns='K8S_node K8S_user K8S_node_ip K8S_node_port K8S_role K8S_su_user K8S_provisionerHost K8S_provisionerUser K8S_provisionerPort'
provision_csv_list="K8S_node  K8S_role K8S_cpuCount K8S_Memory K8S_network K8S_mac K8S_provisionerHost K8S_provisionerUser K8S_provisionerPort K8S_provisionerBasePath K8S_os K8S_virt"

squawk () {
  # This function simplifies error reporting and verbosity
  # call it by preceding your message with a verbosity level
  # e.g. `squawk 3 "This is a squawk"`
  # if the current verbosity level is greater than or equal 
  # the number given then this function will echo out your message
  # and pad it with # to let you now how verbose that message was
  squawk_lvl=$1
  squawk=$2

  if [ "$VERBOSITY" -ge "$squawk_lvl" ] ; then
  count_squawk=0
    while [ "$count_squawk" -lt "$squawk_lvl" ]; do
      echo -n "#"
      count_squawk=`expr $count_squawk + 1`
    done
    echo " $squawk"
  fi
}

horizontal_rule () {
  printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
}

squawk 3 "Kubash, by Josh Cox"

usage () {
  horizontal_rule
  # Print usage
  echo 'kubash, by Josh Cox 2018.01.31
usage: kubash COMMAND
This script automates the setup and maintenance of a kubernetes cluster
e.g.

kubash init
'
  horizontal_rule
echo '
commands:

build - build a base image

provision - provision individual nodes

init - initialize the cluster

decommission - tear down the cluster and decommission nodes

show - show the analyzed input of the hosts file

ping - Perform ansible ping to all hosts

auto - Full auto will provision and initialize all hosts

masters - Perform initialization of masters

nodes - Perform initialization of nodes

dotfiles - Perform dotfiles auto configuration

grab - Grab the .kube/config from the master

hosts - Write ansible hosts file

dry - Perform dry run

'
  horizontal_rule
echo '
options:

 -h --help - Print usage

 -c --csv FILE - Set the csv file to be parsed

 --parallel NUMBER_OF_THREADS - set the number of parallel jobs for tasks that support it

 -v --verbose - Increase the verbosity (can set multiple times to incrementally increase e.g. `-vvvv`

 --verbosity NUMBER - or you can set the verbosity directly

 --debug - adds the debug flag
'
}

node_usage () {
  horizontal_rule
  # Print usage
  echo '--
usage: kubash node_join
build - build a base image

This command joins a node to the cluster
e.g.

kubash node_join

options:

 -h --help - Print usage
 --node-join-name - set node name
 --node-join-user - set node user
 --node-join-ip   - set node ip
 --node-join-port - set node port
 --node-join-role - set node role
'
}

build_usage () {
  horizontal_rule
  # Print usage
  echo '--
usage: kubash build
build - build a base image

This script automates the setup and maintenance of a kubernetes cluster
e.g.

kubash build

options:

 -h --help - Print usage
 --builder - choose builder (packer,coreos)
 --target-os - choose target-os (debian,ubuntu,centos,fedora,coreos)
 --target-build - choose target-build
'
}

init_usage () {
  horizontal_rule
  # Print usage
  echo '--
usage: kubash init
init - init a base image

This script automates the setup and maintenance of a kubernetes cluster
e.g.

kubash init

options:

 -h --help - Print usage
'
}

provision_usage () {
  horizontal_rule
  # Print usage
  echo '--
usage: kubash provision
provision - provision a base image

This script automates the setup and maintenance of a kubernetes cluster
e.g.

kubash provision

options:

 -h --help - Print usage
'
}

decom_usage () {
  horizontal_rule
  # Print usage
  echo '--
usage: kubash decom
decommission - decommission a cluster and destroy all VMs

This script automates the setup and maintenance of a kubernetes cluster
e.g.

kubash decommission

options:

 -h --help - Print usage
'
}

# Check if a command exists
check_cmd () {
  if ! test_cmd_loc="$(type -p "$1")" || [ -z "$test_cmd_loc" ]; then
    echo "$1 was not found in your path!"
    echo "To proceed please install $1 to your path and try again!"
    exit 1
  fi
}

# Check if a file exists and is writable
check_file () {
  if [ -w "$1" ]; then
    echo "$1 was not writable!"
    exit 1
  fi
}

check_cmd mktemp
TMP=$(mktemp -d --suffix='.kubash.tmp' 2>/dev/null || mktemp -d -t '.kubash.tmp')

chkdir () {
  if [ ! -w $1 ] ; then
    sudo mkdir -p $1
    sudo chown $USER. $1
  fi
  if [ ! -w $1 ] ; then
    echo "Cannot write to $1, please check your permissions"
    exit 2
  fi
}

killtmp () {
  cd
  rm -Rf $TMP
}

trap killtmp EXIT
# these vars are used by the following functions
LINE_TO_ADD=''
TARGET_FILE_FOR_ADD=$HOME/.profile

check_if_line_exists()
{
  squawk 7 " Checking for '$LINE_TO_ADD'  in $TARGET_FILE_FOR_ADD"
  grep -qsFx "$LINE_TO_ADD" $TARGET_FILE_FOR_ADD
}

add_line_to()
{
  squawk 5 " Adding '$LINE_TO_ADD'  to $TARGET_FILE_FOR_ADD"
  TARGET_FILE=$TARGET_FILE_FOR_ADD
    [ -w "$TARGET_FILE" ] || TARGET_FILE=$TARGET_FILE_FOR_ADD
    printf "%s\n" "$LINE_TO_ADD" >> "$TARGET_FILE"
}

genmac () {
  # Generate a mac address
  hexchars="0123456789ABCDEF"
  : ${DEFAULT_MAC_ADDRESS_BLOCK:=52:54:00}
  
  if [ ! -z "$1" ]; then
  	DEFAULT_MAC_ADDRESS_BLOCK=$1
  fi
  
  end=$( for i in {1..6} ; do echo -n ${hexchars:$(( $RANDOM % 16 )):1} ; done | sed -e 's/\(..\)/:\1/g' )
  
  echo "$DEFAULT_MAC_ADDRESS_BLOCK$end" >&3
}

rolero () {
  squawk 2 "rolero"
  node_name=$1
  NODE_ROLE=$2
  result=$(kubectl label --overwrite node $node_name node-role.kubernetes.io/$NODE_ROLE=)
  squawk 4 "Result = $result"
}

up () {
  squawk 0 " up"
  run_join=$(ssh -n root@$K8S_master_ip 'kubeadm init --pod-network-cidr=192.168.0.0/16' | tee /tmp/rawresults.k8s | grep -- 'kubeadm join --token')
  echo $run_join > $KUBASH_DIR/join.sh
  ssh -n coopadmin@$K8S_master_ip 'bin/refresh-kube-config'
  chkdir .kube
  ssh -n coopadmin@$K8S_master_ip 'cat .kube/config' > .kube/config
  sudo chmod 600 .kube/config
  sudo chown -R coopadmin. .kube/config
  w8_kubectl
}

kvm-decommer () {
  squawk 5 "kvm-decommer"
  REBASED_NODE=$1

  $PSEUDO virsh destroy $REBASED_NODE
  $PSEUDO virsh undefine $REBASED_NODE

  # Create VM for node
  $PSEUDO rm $KVM_IMAGE_DIR/$REBASED_NODE.qcow2
}

decom_kvm () {
  squawk 1 "decom_kvm"
  # Write all hosts to inventory for id
  while IFS="," read -r $hosts_csv_columns
  do
      kvm-decommer $K8S_node
  done < $KUBASH_HOSTS_CSV
}

vbox-provisioner () {
  squawk 1 "vbox-provisioner"
  
  K8S_node=$1
  K8S_role=$2
  K8S_cpuCount=$3
  K8S_Memory=$4
  K8S_network=$5
  K8S_mac=$6
  K8S_provisionerHost=$7
  K8S_provisionerUser=$8
  K8S_provisionerPort=$9
  K8S_provisionerBasePath=${10}
  K8S_os=${11}
  K8S_virt=${12}
  
  squawk 7 "K8S_node=$1
  K8S_role=$2
  K8S_cpuCount=$3
  K8S_Memory=$4
  K8S_network=$5
  K8S_mac=$6
  K8S_provisionerHost=$7
  K8S_provisionerUser=$8
  K8S_provisionerPort=$9
  K8S_provisionerBasePath=${10}
  K8S_os=${11}
  K8S_virt=${12}
  "

  echo 'Vbox provisioner not implemented yet'
  exit 1
}


qemu-provisioner () {
  squawk 1 "qemu-provisioner"
  
  K8S_node=$1
  K8S_role=$2
  K8S_cpuCount=$3
  K8S_Memory=$4
  K8S_network=$5
  K8S_mac=$6
  K8S_provisionerHost=$7
  K8S_provisionerUser=$8
  K8S_provisionerPort=$9
  K8S_provisionerBasePath=${10}
  K8S_os=${11}
  K8S_virt=${12}
  
  squawk 7 "K8S_node=$1
  K8S_role=$2
  K8S_cpuCount=$3
  K8S_Memory=$4
  K8S_network=$5
  K8S_mac=$6
  K8S_provisionerHost=$7
  K8S_provisionerUser=$8
  K8S_provisionerPort=$9
  K8S_provisionerBasePath=${10}
  K8S_os=${11}
  K8S_virt=${12}
  "

  # Create VM for node
  qemucmd2run="$PSEUDO qemu-img create -f qcow2 -b $K8S_provisionerBasePath/$K8S_os-$KVM_BASE_IMG $K8S_provisionerBasePath/$K8S_node.qcow2"

  virshcmd2run="$PSEUDO virt-install --connect qemu:///system \
 	--import \
  	--autostart \
  	--name $K8S_node \
  	--ram $K8S_Memory \
  	--vcpus $K8S_cpuCount \
  	--os-type=linux \
  	--noautoconsole \
  	--accelerate \
  	--hvm \
  	--os-variant=virtio26 \
  	--disk path=$K8S_provisionerBasePath/$K8S_node.qcow2,format=qcow2,bus=virtio \
  	--network=$K8S_network,mac=$K8S_mac,model=virtio"

  if [ "$K8S_provisionerHost" = "localhost" ]; then
    squawk 5 "$qemucmd2run"
    $qemucmd2run
    squawk 5 "$virshcmd2run"
    $virshcmd2run
  else
    squawk 5 "ssh -n -p $K8S_provisionerPort $K8S_provisionerUser@$K8S_provisionerHost $qemucmd2run"
    ssh -n -p $K8S_provisionerPort $K8S_provisionerUser@$K8S_provisionerHost "$qemucmd2run"
    squawk 5 "ssh -n -p $K8S_provisionerPort $K8S_provisionerUser@$K8S_provisionerHost $virshcmd2run"
    ssh -n -p $K8S_provisionerPort $K8S_provisionerUser@$K8S_provisionerHost "$virshcmd2run"
  fi
}

provisioner () {
  squawk 1 " provisioner"
  slurpy="$(grep -v '^#' $KUBASH_DIR/provision.list)"
  squawk 8 "$slurpy"
  if [ -e "$KUBASH_DIR/hosts.csv" ]; then
    horizontal_rule
    echo "$KUBASH_DIR/hosts.csv exists! Destroy existing cluster and remove before proceeding!"
    if [ "$ANSWER_YES" = "yes" ]; then
      rm hosts.csv
    else
      rm -i hosts.csv
    fi
  fi
  touch hosts.csv
  while IFS="," read -r $provision_csv_list
  do
      squawk 19 "qemu-provisioner $K8S_node $K8S_role $K8S_cpuCount $K8S_Memory $K8S_network $K8S_mac $K8S_provisionerHost $K8S_provisionerUser $K8S_provisionerPort $K8S_provisionerBasePath"
      if [ "$K8S_virt" = "qemu" ]; then
        qemu-provisioner $K8S_node $K8S_role $K8S_cpuCount $K8S_Memory $K8S_network $K8S_mac $K8S_provisionerHost $K8S_provisionerUser $K8S_provisionerPort $K8S_provisionerBasePath $K8S_os $K8S_virt
      elif [ "$K8S_virt" = "vbox" ]; then
        vbox-provisioner $K8S_node $K8S_role $K8S_cpuCount $K8S_Memory $K8S_network $K8S_mac $K8S_provisionerHost $K8S_provisionerUser $K8S_provisionerPort $K8S_provisionerBasePath $K8S_os $K8S_virt
      else
	echo "virtualization technology '$K8S_virt' not recognized"
      fi
      sleep 5
      squawk 4 "provisioned"
      if [ "$K8S_provisionerHost" = "localhost" ]; then
        while [[ -z "$K8S_node_ip" ]]; do
          squawk 7 "checking for IP address"
          squawk 8 "$PSEUDO virsh domifaddr $K8S_node --full"
          K8S_node_ip=$($PSEUDO virsh domifaddr $K8S_node --full|grep ipv4|head -n1|awk '{print $4}'|cut -f1 -d/ 2>/dev/null)
  	sleep 2
        done
      else
        if [ "$K8S_provisionerHost" = "localhost" ]; then
        while [[ -z "$K8S_node_ip" ]]; do
          squawk 7 "checking for IP address"
          squawk 8 "$PSEUDO virsh domifaddr $K8S_node --full"
          K8S_node_ip=$(ssh -n -p $K8S_provisionerPort $K8S_provisionerUser@$K8S_provisionerHost "$PSEUDO virsh domifaddr $K8S_node --full|grep ipv4|head -n1|awk '{print $4}'|cut -f1 -d/ 2>/dev/null")
  	sleep 2
        done
        fi
      fi
      squawk 5 "adding to hosts.csv"
      squawk 6 "$K8S_node,$K8S_user,$K8S_node_ip,$K8S_node_port,$K8S_role,$K8S_su_user"
      echo "$K8S_node,$K8S_user,$K8S_node_ip,$K8S_node_port,$K8S_role,$K8S_su_user,$K8S_provisionerHost,$K8S_provisionerUser,$K8S_provisionerPort" >> $KUBASH_DIR/hosts.csv
      K8S_node_ip=''
  done <<< "$slurpy"
}

do_net () {
  squawk 0 " do_net"
  if [[ $K8S_NET == "calico" ]]; then
    kubectl apply -f https://docs.projectcalico.org/v2.6/getting-started/kubernetes/installation/hosted/kubeadm/1.6/calico.yaml
  fi
}

do_tiller () {
  w8_kubedns
  squawk 1 " do_tiller"
  kubectl create serviceaccount tiller --namespace kube-system
  kubectl create -f $KUBASH_DIR/tiller/rbac-tiller-config.yaml
  helm init --service-account tiller
}

mid () {
  squawk 1 " mid"
  do_net
  do_tiller
}

hosts () {
	#intermediary compatibility layer
	echo 'warning hosts function deprecated use write_ansible_hosts instead'
	sleep 4
	write_ansible_hosts
}

write_ansible_hosts () {
  squawk 1 " Make a hosts file for ansible"
  # Make a fresh hosts file
  if [ -e "$KUBASH_HOSTS" ]; then
    horizontal_rule
    echo " $KUBASH_HOSTS exists! Destroy running and cluster and remove before proceeding!"
    if [ "$ANSWER_YES" = "yes" ]; then
      rm $KUBASH_HOSTS
    else
      rm -i $KUBASH_HOSTS
    fi
    touch $KUBASH_HOSTS
  else
    touch $KUBASH_HOSTS
  fi
  # Write all hosts to inventory for id
  while IFS="," read -r $hosts_csv_columns
  do
    echo "$K8S_node ansible_ssh_host=$K8S_node_ip ansible_ssh_port=$K8S_node_port ansible_user=$K8S_user" >> $KUBASH_HOSTS
  done < $KUBASH_HOSTS_CSV

  echo '' >> $KUBASH_HOSTS

  echo '[kubernetes-kubeminions]' >> $KUBASH_HOSTS
  while IFS="," read -r $hosts_csv_columns
  do
    if [[ $K8S_role == "node" ]]; then
      echo "$K8S_node" >> $KUBASH_HOSTS
    fi
  done < $KUBASH_HOSTS_CSV

  echo '' >> $KUBASH_HOSTS

  echo '[kubernetes-kubeminions:vars]' >> $KUBASH_HOSTS
  echo 'ansible_ssh_extra_args="-o StrictHostKeyChecking=no"' >> $KUBASH_HOSTS

  echo '' >> $KUBASH_HOSTS

  echo '[kubernetes-kubemasters]' >> $KUBASH_HOSTS
  while IFS="," read -r $hosts_csv_columns
  do
    if [[ $K8S_role == "master" ]]; then
      echo "$K8S_node" >> $KUBASH_HOSTS
    fi
  done < $KUBASH_HOSTS_CSV

  echo '' >> $KUBASH_HOSTS

  echo '[kubernetes-kubemasters:vars]' >> $KUBASH_HOSTS
  echo 'ansible_ssh_extra_args="-o StrictHostKeyChecking=no"' >> $KUBASH_HOSTS
}

removestalekeys () {
  squawk 1 " removestalekeys"
  node_ip=$1
  ssh-keygen -f "/home/coopadmin/.ssh/known_hosts" -R "$node_ip"
}

w8_kubedns () {
  echo -n "wait on Kube-DNS to become available"
  sleep 1
  
  # while loop
  countone=1
  # timeout for 15 minutes
  while [ $countone -lt 151 ]
  do
    echo -n '.'
    RESULT=$(kubectl get po --namespace kube-system |grep kube-dns|grep Running)
    if [ "$RESULT" ]; then
        sleep 3
        echo '.'
        echo "$RESULT"
        break
    fi
    countone=`expr $countone + 1`
    sleep 3
  done
  
  echo "Kube-DNS is now up and running"
  sleep 1
}

w8_kubectl () {
  echo -n "# wait on the K8S cluster to become available"
  sleep 15
  # while loop
  countone_w8_kubectl=1
  countlimit_w8_kubectl=151
  # timeout for 15 minutes
  while [ "$countone_w8_kubectl" -lt "$countlimit_w8_kubectl" ]; do
    echo -n '.'
    if [ "$VERBOSITY" -gt "11" ] ; then
      kubectl get pods -n kube-system | grep kube-apiserver
    fi
    result=$(kubectl get pods -n kube-system | grep kube-apiserver |grep Running)
    squawk 13 "Result is $result"
    if [[ "$result" ]]; then
      squawk 15 "Result nailed $result"
      countone_w8_kubectl=`expr $countlimit_w8_kubectl + 1`
      break
    fi
    countone_w8_kubectl=`expr $countone_w8_kubectl + 1`
    squawk 19 "$countone_w8_kubectl"
    sleep 5
  done
  echo  "."
  echo  "kubectl commands are now able to interact with the kubernetes cluster"
}

w8_node () {
  node_name=$1
  echo -n "# wait on the K8S node $node_name to become available"
  sleep 5
  # while loop
  countone_w8_node=1
  countlimit_w8_node=151
  # timeout for 15 minutes
  while [ "$countone_w8_node" -lt "$countlimit_w8_node" ]; do
    echo -n '.'
    if [ "$VERBOSITY" -gt "11" ] ; then
      kubectl get node $node_name
    fi
    result=$(kubectl get node $node_name | grep -v NotReady | grep Ready)
    squawk 13 "Result is $result"
    if [ "$result" ]; then
      squawk 15 "Result nailed $result"
      countone_w8_node=`expr $countlimit_w8_node + 1`
      break
    fi
    countone_w8_node=`expr $countone_w8_node + 1`
    squawk 19 "$countone_w8_node"
    sleep 3
  done
  echo  "."
  echo  "kubectl commands are now able to interact with the kubernetes node"
}

remove_vagrant_user () {
  PARATMP=$(mktemp -d --suffix='.para.tmp' 2>/dev/null || mktemp -d -t '.para.tmp')
  squawk 2 ' Remove vagrant user from all hosts using ssh'
  while IFS="," read -r $hosts_csv_columns
  do
    squawk 1 "$K8S_node_ip"
    squawk 3 "$K8S_user"
    REMMY="userdel -f vagrant && rm -Rf /home/vagrant"
    squawk 5 "ssh -n -p $K8S_node_port $K8S_user@$K8S_node_ip \"$REMMY\""
	      >> $PARATMP/hopper
    echo "ssh -n -p $K8S_node_port $K8S_user@$K8S_node_ip \"$REMMY\""\
	      >> $PARATMP/hopper
  done < $KUBASH_HOSTS_CSV

  if [ "$VERBOSITY" -gt "9" ] ; then
    cat $PARATMP/hopper
  fi
  if [ "$PARALLEL_JOBS" -gt "1" ] ; then
    $PARALLEL  -j $PARALLEL_JOBS -- < $PARATMP/hopper
  else
    bash $PARATMP/hopper
  fi
  rm -Rf $PARATMP
}

ping_in_parallel () {
  PARATMP=$(mktemp -d --suffix='.para.tmp' 2>/dev/null || mktemp -d -t '.para.tmp')
  squawk 2 ' Pinging all hosts using ssh'
  while IFS="," read -r $hosts_csv_columns
  do
    squawk 1 "$K8S_node_ip"
    squawk 3 "$K8S_user"
    MY_ECHO="echo '$K8S_node_ip $K8S_su_user pong'" 
    squawk 5 "ssh -n -p $K8S_node_port $K8S_su_user@$K8S_node_ip \"$MY_ECHO\""
	      >> $PARATMP/hopper
    echo "ssh -n -p $K8S_node_port $K8S_su_user@$K8S_node_ip \"$MY_ECHO\""\
	      >> $PARATMP/hopper
    MY_ECHO="echo '$K8S_node_ip $K8S_user pong'" 
    squawk 5 "ssh -n -p $K8S_node_port $K8S_user@$K8S_node_ip \"$MY_ECHO\""
	      >> $PARATMP/hopper
    echo "ssh -n -p $K8S_node_port $K8S_user@$K8S_node_ip \"$MY_ECHO\""\
	      >> $PARATMP/hopper
  done < $KUBASH_HOSTS_CSV

  if [ "$VERBOSITY" -gt "9" ] ; then
    cat $PARATMP/hopper
  fi
  if [ "$PARALLEL_JOBS" -gt "1" ] ; then
    $PARALLEL  -j $PARALLEL_JOBS -- < $PARATMP/hopper
  else
    bash $PARATMP/hopper
  fi
  rm -Rf $PARATMP
}

ping () {
  squawk 2 ' Pinging all hosts using ssh'
  while IFS="," read -r $hosts_csv_columns
  do
    squawk 1 "$K8S_node_ip"
    squawk 3 "$K8S_user"
    ssh -n -p $K8S_node_port $K8S_user@$K8S_node_ip 'echo pong'
    squawk 3 "$K8S_su_user"
    ssh -n -p $K8S_node_port $K8S_su_user@$K8S_node_ip 'echo pong'
  done < $KUBASH_HOSTS_CSV
}

ansible-ping () {
  squawk 1 ' Pinging all hosts using Ansible'
  ansible -i $KUBASH_HOSTS -m ping all
}

hostnamero () {
  my_HOST=$1
  my_IP=$2
  my_PORT=$3
  my_USER=$4
  squawk 1 " hostnamero my_HOST=$my_HOST my_IP=$my_IP my_PORT=$my_PORT my_USER=$my_USER"
  result=$(ssh -n -p $my_PORT root@$my_IP "hostname $my_HOST && echo $my_HOST > /etc/hostname && echo \"127.0.1.1 $my_HOST.$my_DOMAIN $my_HOST  \" >> /etc/hosts ")
  squawk 13 "Result is $result"
}

chkdir () {
  if [ ! -w $1 ] ; then
    sudo mkdir -p $1
    sudo chown $USER. $1
  fi
  if [ ! -w $1 ] ; then
    echo "Cannot write to $1, please check your permissions"
    exit 2
  fi
}

dotfiles_install () {
  squawk 1 ' Adjusting dotfiles'
  touch $HOME/.zshrc
  touch $HOME/.bashrc
  # make a bin dir in $HOME and add it to path
  chkdir $KUBASH_BIN
  LINE_TO_ADD="$(printf "export PATH=%s:\$PATH" $KUBASH_BIN)"
  TARGET_FILE_FOR_ADD=$HOME/.bashrc
  check_if_line_exists || add_line_to
  TARGET_FILE_FOR_ADD=$HOME/.zshrc
  check_if_line_exists || add_line_to

  LINE_TO_ADD="export GOPATH=$GOPATH"
  TARGET_FILE_FOR_ADD=$HOME/.bashrc
  check_if_line_exists || add_line_to
  TARGET_FILE_FOR_ADD=$HOME/.zshrc
  check_if_line_exists || add_line_to
}

linux_install () {
  squawk 1 " linux_install"
  cd $TMP
  dotfiles_install
}

do_grab () {
  squawk 1 " do_grab"
  do_grab_master_count=0
  while IFS="," read -r $hosts_csv_columns
  do
    if [[ $K8S_role == "init_master" ]]; then
      if [ "$do_grab_master_count" -lt "1" ]; then
        master_grab_kube_config $K8S_node $K8S_node_ip $K8S_su_user $K8S_node_port
      fi
      do_grab_master_count=`expr $do_grab_master_count + 1`
    fi
  done < $KUBASH_HOSTS_CSV
}

master_join () {
  my_node_name=$1
  my_node_ip=$2
  my_node_user=$3
  my_node_port=$4
  squawk 1 " master_join $my_node_name $my_node_ip $my_node_user $my_node_port"
  if [ "$DO_MASTER_JOIN" = "true" ] ; then
    hostnamero $my_node_name $my_node_ip $my_node_port $my_node_user
    squawk 3 " kubadm reset"
    ssh -n -p $my_node_port $my_node_user@$my_node_ip "hostname; uname -a;kubeadm reset"
    run_join=$(cat $KUBASH_DIR/join.sh)
    squawk 1 " run join $run_join"
    ssh -n -p $my_node_port $my_node_user@$my_node_ip "$run_join"
    w8_node $my_node_name
    rolero $my_node_name master
  fi
}

master_init_join () {
  my_master_name=$1
  my_master_ip=$2
  my_master_user=$3
  my_master_port=$4
  if [[ $K8S_NET == "calico" ]]; then
    my_KUBE_CIDR="192.168.0.0/16"
  fi
  squawk 0 " master_init_join $my_master_name $my_master_ip $my_master_user $my_master_port"
  if [ "$DO_MASTER_JOIN" = "true" ] ; then
    squawk 1 ' hostnamero'
    hostnamero $my_master_name $my_master_ip $my_master_port $my_master_user
    squawk 3 ' kubeadm reset'
    ssh -n -p $my_master_port $my_master_user@$my_master_ip "hostname; uname -a;kubeadm reset"
    my_grep='kubeadm join --token'
    squawk 3 ' kubeadm join'
    my_KUBE_INIT="kubeadm init --pod-network-cidr=$my_KUBE_CIDR"
    squawk 5 "$my_KUBE_INIT"
    run_join=$(ssh -n root@$my_master_ip $my_KUBE_INIT | tee $TMP/rawresults.k8s | grep -- "$my_grep")
    echo $run_join > $KUBASH_DIR/join.sh
    DO_GRAB=true
    master_grab_kube_config $my_master_name $my_master_ip $K8S_su_user $my_master_port
    w8_kubectl
  fi
}

master_grab_kube_config () {
  my_master_name=$1
  my_master_ip=$2
  my_master_user=$3
  my_master_port=$4
  squawk 1 ' refresh-kube-config'
  squawk 3 " master_grab_kube_config $my_master_name $my_master_ip $my_master_user $my_master_port"
  if [ "$DO_GRAB" = "true" ] ; then
    squawk 5 "mkdir -p ~/.kube && sudo cp -av /etc/kubernetes/admin.conf ~/.kube/config && sudo chown -R $my_master_user. ~/.kube"
    ssh -n -p $my_master_port $my_master_user@$my_master_ip "mkdir -p ~/.kube && sudo cp -av /etc/kubernetes/admin.conf ~/.kube/config && sudo chown -R $my_master_user. ~/.kube"

    chkdir $HOME/.kube
    squawk 3 ' grab config'
    rm -f $HOME/.kube/config
    ssh -n -p $my_master_port $my_master_user@$my_master_ip 'cat .kube/config' > $HOME/.kube/config
    sudo chmod 600 $HOME/.kube/config
    sudo chown -R coopadmin. $HOME/.kube/config
    DO_GRAB=false
  fi
}

node_join () {
  my_node_name=$1
  my_node_ip=$2
  my_node_user=$3
  my_node_port=$4
  squawk 1 " node_join $my_node_name $my_node_ip $my_node_user $my_node_port"
  if [ "$DO_NODE_JOIN" = "true" ] ; then
    hostnamero $my_node_name $my_node_ip $my_node_port
    result=$(ssh -n -p $my_node_port $my_node_user@$my_node_ip "hostname; uname -a;kubeadm reset")
    squawk 13 "Result is $result"
    run_join=$(cat $KUBASH_DIR/join.sh)
    result=$(ssh -n -p $my_node_port $my_node_user@$my_node_ip "$run_join")
    squawk 13 "Result is $result"
    w8_node $my_node_name
    rolero $my_node_name node
  fi
}

checks () {
  squawk 10 " checks"
  check_cmd git
  check_cmd ssh
  check_cmd ansible
  check_cmd curl
  check_cmd uname
  check_cmd expr
  if [ "$PARALLEL_JOBS" -gt "1" ] ; then
    check_cmd parallel
  fi
  check_cmd 'grep'
  check_cmd 'sed'
}

do_install () {
  squawk 1 " do_install"
  UNAME=$(uname)

  if [ "$UNAME" = "CYGWIN_NT-10.0" ] ; then
    PLATFORM="os.cygwin.x86_64"
    echo "WARNING: Cygwin is not supported at this time!"
    exit 1
  fi

  if [ "$UNAME" == "Linux" ] ; then
    squawk 1 " $UNAME is a Supported OS"
  elif [ "$UNAME" == "Darwin" -o "$UNAME" == "FreeBSD" ] ; then
      echo " $UNAME is not a Supported OS"
      exit 1
  elif [ "$UNAME" ">" "MINGW" -a "$UNAME" "<" "MINGX" ] ; then
      echo "# $UNAME is not a Supported OS"
      exit 1
  else
    echo " $UNAME is not a Supported OS"
    echo "Sorry, this OS is not supported yet via this installer."
    exit 1
  fi

  if [ "$UNAME" = "Linux" ] ; then
    ### Linux ###
    LINUX_ARCH=$(uname -m)
    if [ "${LINUX_ARCH}" = "x86_64" ] ; then
      PLATFORM="os.linux.x86_64"
    else
      echo "Unusable architecture: ${LINUX_ARCH}"
      echo "ReactioNstall only supports x86_64 for now on Linux."
      exit 1
    fi
  fi

  # make reqs
  if [ "$PLATFORM" = "os.linux.x86_64" ] ; then
    linux_install
  fi
}

initialize () {
  squawk 1 " initialize"
  check_csv
  do_csv
}

old-initialize () {
  squawk 0 " old_initialize"
  do_install
  removestalekeys $K8S_master_ip
  removestalekeys $K8S_node1_IP
  removestalekeys $K8S_node2_IP
  ping
  master_join $K8S_MASTER $K8S_master_ip root
  master_grab_kube_config $K8S_MASTER $K8S_master_ip coopadmin
  w8_kubectl
  node_join $K8S_node1 $K8S_node1_IP root
  node_join $K8S_node2 $K8S_node2_IP root
  mid
}

read_csv () {
  squawk 1 " read_csv"
  read_master_count=0

  while IFS="," read -r $hosts_csv_columns
  do
    squawk 5 "$K8S_node $K8S_user $K8S_node_ip $K8S_node_port $K8S_role $K8S_su_user $K8S_provisionerHost $K8S_provisionerUser $K8S_provisionerPort"
    if [[ $K8S_role == "master" ]]; then
      if [ "$read_master_count" -lt "1" ]; then
        echo "master_init_join $K8S_node $K8S_node_ip $K8S_user $K8S_node_port"
      else
        echo "master_join $K8S_node $K8S_node_ip $K8S_user $K8S_node_port"
      fi
      read_master_count=`expr $read_master_count + 1`
    fi
  done < $KUBASH_HOSTS_CSV

  while IFS="," read -r $hosts_csv_columns
  do
    if [[ $K8S_role == "node" ]]; then
      echo "node_join $K8S_node $K8S_node_ip $K8S_user $K8S_node_port"
    fi
  done < $KUBASH_HOSTS_CSV
}

check_csv () {
  squawk 4 " check_csv"
  if [ ! -e $KUBASH_HOSTS_CSV ]; then
    echo 'CSV file not found.  You must specify a valid csv file with the --csv option!'
    exit 1
  fi
}

do_init_master () {
  squawk 3 " do_masters"
  do_master_count=0

  while IFS="," read -r $hosts_csv_columns
  do
    if [[ $K8S_role == "init_master" ]]; then
      if [ "$do_master_count" -lt "1" ]; then
        master_init_join $K8S_node $K8S_node_ip $K8S_user $K8S_node_port
      else
	echo 'There should only be one init master! Skipping this master'
        echo "master_init_join $K8S_node $K8S_node_ip $K8S_user $K8S_node_port"
      fi
      do_master_count=`expr $do_master_count + 1`
    fi
  done < $KUBASH_HOSTS_CSV
}

do_masters () {
  squawk 3 " do_masters"

  while IFS="," read -r $hosts_csv_columns
  do
    if [[ $K8S_role == "master" ]]; then
      kubash node_join --node-join-name $K8S_node --node-join-ip $K8S_node_ip --node-join-user $K8S_user --node-join-port $K8S_node_port --node-join-role master
    fi
  done < $KUBASH_HOSTS_CSV
}

do_masters_in_parallel () {
  PARATMP=$(mktemp -d)
  squawk 3 " do_masters_in_parallel"
  do_master_count=0

  # We can parallelize the rest, but the first master we will do alone and wait on it
  while IFS="," read -r $hosts_csv_columns
  do
    if [[ $K8S_role == "master" ]]; then
      echo "kubash node_join --node-join-name $K8S_node --node-join-ip $K8S_node_ip --node-join-user $K8S_user --node-join-port $K8S_node_port --node-join-role master" \
	      >> $PARATMP/hopper
    fi
  done < $KUBASH_HOSTS_CSV

  if [ "$VERBOSITY" -gt "9" ] ; then
    cat $PARATMP/hopper
  fi
  if [ "$PARALLEL_JOBS" -gt "1" ] ; then
    $PARALLEL  -j $PARALLEL_JOBS -- < $PARATMP/hopper
  else
    bash $PARATMP/hopper
  fi
  rm -Rf $PARATMP
}

do_nodes () {
  squawk 3 " do_nodes"
  countzero_do_nodes=0
  while IFS="," read -r $hosts_csv_columns
  do 
    if [[ $K8S_role == "node" ]]; then
      node_join $K8S_node $K8S_node_ip $K8S_user $K8S_node_port
    else
      squawk 11 " K8S_role NOT NODE"
      squawk 11 " K8S_role $K8S_role $K8S_node_ip $K8S_user $K8S_node_port"
    fi
    countzero_do_nodes=`expr $countzero_do_nodes + 1`
    squawk 11 " count $countzero_do_nodes"
  done < $KUBASH_HOSTS_CSV
}

do_nodes_in_parallel () {
  PARATMP=$(mktemp -d)
  touch $PARATMP/hopper
  squawk 3 " do_nodes_in_parallel"
  countzero_do_nodes=0
  while IFS="," read -r $hosts_csv_columns
  do 
    if [[ $K8S_role == "node" ]]; then
      echo "kubash node_join --node-join-name $K8S_node --node-join-ip $K8S_node_ip --node-join-user $K8S_user --node-join-port $K8S_node_port --node-join-role node" \
	      >> $PARATMP/hopper
    else
      squawk 11 " K8S_role NOT NODE"
      squawk 11 " K8S_role $K8S_role $K8S_node_ip $K8S_user $K8S_node_port"
    fi
    countzero_do_nodes=`expr $countzero_do_nodes + 1`
    squawk 13 " count $countzero_do_nodes"
  done < $KUBASH_HOSTS_CSV

  if [ "$VERBOSITY" -gt "9" ] ; then
    cat $PARATMP/hopper
  fi
  if [ "$PARALLEL_JOBS" -gt "1" ] ; then
    $PARALLEL  -j $PARALLEL_JOBS -- < $PARATMP/hopper
  else
    bash $PARATMP/hopper
  fi
  rm -Rf $PARATMP
}

do_csv () {
  squawk 3 " do_csv"
  do_init_master
  if [ "$PARALLEL_JOBS" -gt "1" ] ; then
    do_masters_in_parallel
    do_nodes_in_parallel
  else
    do_masters
    do_nodes
  fi
}

prep () {
  squawk 5 " prep"
  while IFS="," read -r $hosts_csv_columns
  do
    preppy $K8S_node $K8S_node_ip $K8S_node_port
  done < $KUBASH_HOSTS_CSV
  remove_vagrant_user
}

preppy () {
  squawk 7 " preppy"
  node_name=$1
  node_ip=$2
  node_port=$3
  removestalekeys $node_ip
  ssh-keyscan -p $node_port $node_ip >> ~/.ssh/known_hosts
}

do_decom () {
  read -p "This will destroy all VMs defined in the hosts.csv. Are you sure? [y/N] " -n 1 -r
  echo    # (optional) move to a new line
  if [[ $REPLY =~ ^[Yy]$ ]]
  then
    decom_kvm
  fi
}

do_openebs () {
	kubectl create -f https://raw.githubusercontent.com/openebs/openebs/master/k8s/openebs-operator.yaml
	kubectl create -f https://raw.githubusercontent.com/openebs/openebs/master/k8s/openebs-storageclasses.yaml
}

coreos_build  () {
  build_virt=$1
  target_os=$2
  CHANNEL=$3
  chkdir $KUBASH_BUILDS
  chkdir $KUBASH_BUILDS_TMP

  cd $KUBASH_BUILDS_TMP
  wget -c https://$(CHANNEL).release.core-os.net/amd64-usr/current/coreos_production_qemu_image.img.bz2{,.sig}
  gpg --verify coreos_production_qemu_image.img.bz2.sig
  rm coreos_production_qemu_image.img.bz2.sig
  bunzip2 coreos_production_qemu_image.img.bz2

  if [[ $VERBOSITY -gt '1' ]]; then
    if [ "$ANSWER_YES" = "yes" ]; then
      MV_CMD='mv -v'
    else
      MV_CMD='mv -iv'
    fi
  else
    if [ "$ANSWER_YES" = "yes" ]; then
      MV_CMD='mv'
    else
      MV_CMD='mv -i'
    fi
  fi

  $PSEUDO $MV_CMD \
    $KUBASH_BUILDS_TMP/coreos_production_qemu_image.img \
    $KVM_IMAGE_DIR/$target_os-$KVM_BASE_IMG
}

packer_build  () {
  build_virt=$1
  target_os=$2
  target_build=$3
  chkdir $KUBASH_BUILDS
  chkdir $KUBASH_BUILDS_TMP

  if [[ $VERBOSITY -gt '1' ]]; then
    LN_CMD='ln -sv'
  else
    LN_CMD='ln -s'
  fi
  if [[ $VERBOSITY -gt '1' ]]; then
    if [ "$ANSWER_YES" = "yes" ]; then
      MV_CMD='mv -v'
    else
      MV_CMD='mv -iv'
    fi
  else
    if [ "$ANSWER_YES" = "yes" ]; then
      MV_CMD='mv'
    else
      MV_CMD='mv -i'
    fi
  fi

  cd $KUBASH_DIR/pax
  if [ ! -L build ]; then
    $LN_CMD $KUBASH_BUILDS builds
  fi

  cd $KUBASH_DIR/pax/$target_os
  check_cmd packer
  squawk 2 " Executing packer build..."

  if [[ $debug == "true" ]]; then
    debug_flag='-debug -on-error=ask'
    PACKER_LOG=1
  else
    debug_flag=''
    PACKER_LOG=0
  fi
  squawk 2 "TMPDIR=$KUBASH_BUILDS_TMP packer build -only=$build_virt $debug_flag $target_build.json"
  PACKER_LOG=$PACKER_LOG \
  TMPDIR=$KUBASH_BUILDS_TMP \
    packer build -only=$build_virt $debug_flag $target_build.json

  if [[ $VERBOSITY -gt '1' ]]; then
    if [ "$ANSWER_YES" = "yes" ]; then
      MV_CMD='mv -v'
    else
      MV_CMD='mv -iv'
    fi
  else
    if [ "$ANSWER_YES" = "yes" ]; then
      MV_CMD='mv'
    else
      MV_CMD='mv -i'
    fi
  fi

  $PSEUDO $MV_CMD \
    $KUBASH_BUILDS/packer-$target_build-$build_virt/$target_build \
    $KVM_IMAGE_DIR/$target_os-$KVM_BASE_IMG
  rmdir $KUBASH_BUILDS/packer-$target_build-$build_virt
}

activate_monitoring () {
  # Prometheus
  helm install stable/prometheus
}

main () {
  # save original io
  exec 3>&1 4>&2
  # Let's display everything on stderr.
  exec 1>&2

  # If cmd empty print usage
  if [[ -z "$1" ]]; then
    squawk 5 "No Args found printing usage"
    usage
    exit 1
  fi

  squawk 5 'parse opts'

  # Execute getopt on the arguments passed to this program, identified by the special character $@
  SHORT_OPTS="c:hvy"
  LONG_OPTS="csv:,help,yes,verbose,verbosity:,target-os:,target-build:,build-virt:,node-join-name:,node-join-user:,node-join-ip:,node-join-port:,node-join-role:,parallel:,builder:,debug"
  PARSED_OPTIONS=$(getopt -n "$0" -o "$SHORT_OPTS" --long "$LONG_OPTS" -- "$@")

  #Bad arguments, something has gone wrong with the getopt command.
  if [ $? -ne 0 ];
  then
    exit 1
  fi

  # A little magic, necessary when using getopt.
  eval set -- "$PARSED_OPTIONS"

  squawk 5 'loop through opts'

  opt_loop_count=1
  while true; do
    squawk 15 "$opt_loop_count $@"
    opt_loop_count=`expr $opt_loop_count + 1`
    case "$1" in
      -h|--help)
        print_help=true
        shift;;
      --debug)
        debug=true
        shift;;
      -y|--yes)
	ANSWER_YES=yes
        shift;;
      -c|--csv)
        KUBASH_HOSTS_CSV="$2"
        RAISON=true
        shift 2 ;;
      --parallel)
        PARALLEL_JOBS="$2"
        shift 2 ;;
      --node-join-name)
        node_join_name="$2"
        shift 2 ;;
      --node-join-user)
        node_join_user="$2"
        shift 2 ;;
      --node-join-ip)
        node_join_ip="$2"
        shift 2 ;;
      --node-join-port)
        node_join_port="$2"
        shift 2 ;;
      --node-join-role)
        node_join_role="$2"
        shift 2 ;;
      --target-os)
	target_os="$2"
        shift 2 ;;
      --target-build)
	target_build="$2"
        shift 2 ;;
      --build-virt)
	build_virt="$2"
        shift 2 ;;
      -v|--verbose)
        VERBOSITY=`expr $VERBOSITY + 1`
        shift;;
      --verbosity)
        VERBOSITY=`expr $VERBOSITY + $2`
        squawk 2 " verbosity is now $VERBOSITY"
        shift 2 ;;
      --builder)
        builder=$2
        shift 2 ;;
      --)
        shift
        break;;
    esac
  done

    squawk 7 "Check args"

  if [ $# -gt 1 ]; then
    usage
    exit 1
  fi

  if [ $# -eq 1 ]; then
    RAISON=$1
    squawk 5 "Raison set to $RAISON"
  fi

  checks

  if [ $RAISON = "false" -o "$RAISON" = "help" ]; then
    usage
    exit 1
  fi

  if [[ $RAISON == "auto" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
	squawk 1 "Full auto engaged"
	kubash provision
	kubash ping
	kubash init
	squawk 1 "Full auto finished"
      exit
  elif [[ $RAISON == "grab" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
        DO_GRAB=true
  elif [[ $RAISON == "openebs" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
        DO_OPENEBS=true
  elif [[ $RAISON == "genmac" ]]; then
    genmac
  elif [[ $RAISON == "dry" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
        DO_HOSTS=true
        DO_PING=true
        DO_CSV=true
        VERBOSITY=`expr $VERBOSITY + 1`
  elif [[ $RAISON == "hosts" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
        DO_HOSTS=true
  elif [[ $RAISON == "dotfiles" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
        dotfiles_install
        DO_GRAB=true
  elif [[ $RAISON == "show" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
      DO_SHOW=true
      VERBOSITY=`expr $VERBOSITY + 1`
  elif [[ $RAISON == "ping" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
      DO_PING=true
  elif [[ $RAISON == "aping" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
      DO_HOSTS=true
      DO_APING=true
  elif [[ $RAISON == "monitoring" ]]; then
    if [[ $print_help == "true" ]]; then
      usage
      exit 1
    fi
      activate_monitoring
  elif [[ $RAISON == "prep" ]]; then
    prep
  elif [[ $RAISON == "provision" ]]; then
    if [[ $print_help == "true" ]]; then
      provision_usage
      exit 1
    fi
    provisioner
    sleep 10
    prep
  elif [[ $RAISON == "decommission" ]]; then
    if [[ $print_help == "true" ]]; then
      decom_usage
      exit 1
    fi
    do_decom
  elif [[ $RAISON == "masters" ]]; then
    if [[ $print_help == "true" ]]; then
      init_usage
      exit 1
    fi
        DO_CSV=true
        DO_NET=true
        DO_PING=true
        DO_GRAB=true
        DO_HOSTS=true
        DO_TILLER=true
        DO_INSTALL=true
        DO_MASTER_JOIN=true
  elif [[ $RAISON == "nodes" ]]; then
    if [[ $print_help == "true" ]]; then
      init_usage
      exit 1
    fi
        DO_CSV=true
        DO_PING=true
        DO_HOSTS=true
        DO_NODE_JOIN=true
  elif [[ $RAISON == "init" ]]; then
    if [[ $print_help == "true" ]]; then
      init_usage
      exit 1
    fi
        DO_CSV=true
        DO_NET=true
        DO_PING=true
        DO_GRAB=true
        DO_HOSTS=true
        DO_INSTALL=true
        do_dotfiles=true
        DO_NODE_JOIN=true
        DO_MASTER_JOIN=true
  elif [[ $RAISON == "tiller" ]]; then
    if [[ $print_help == "true" ]]; then
      init_usage
      exit 1
    fi
        DO_TILLER=true
  elif [[ $RAISON == "build" ]]; then
    if [[ $print_help == "true" ]]; then
      build_usage
      exit 1
    fi
    if [[ -z "$builder" ]]; then
      builder='packer'
    fi
    if [[ -z "$target_os" ]]; then
      target_os=ubuntu
      if [[ -z "$target_build" ]]; then
        target_build=ubuntu-16.04-amd64
      fi
    elif [[ "$target_os" == "ubuntu" ]]; then
      if [[ -z "$target_build" ]]; then
        target_build=ubuntu-16.04-amd64
      fi
    elif [[ "$target_os" == "debian" ]]; then
      if [[ -z "$target_build" ]]; then
        target_build=debian-9.3-amd64
      fi
    elif [[ "$target_os" == "centos" ]]; then
      if [[ -z "$target_build" ]]; then
        target_build=centos-7.4-x86_64
      fi
    elif [[ "$target_os" == "fedora" ]]; then
      if [[ -z "$target_build" ]]; then
        target_build=fedora-27-x86_64
      fi
    elif [[ "$target_os" == "coreos" ]]; then
      if [[ -z "$target_build" ]]; then
	squawk 5 "Setting coreos channel to stable"
        target_build=stable
      fi
    fi
    if [[ -z "$target_build" ]]; then
      target_build=ubuntu-16.04-amd64
    fi
    if [[ -z "$build_virt" ]]; then
      build_virt=qemu
    fi
    if [[ $builder == "packer" ]]; then
      squawk 5 "packer_build $build_virt $target_os $target_build"
      packer_build $build_virt $target_os $target_build
    elif [[ $builder == "coreos" ]]; then
      squawk 5 "coreos_build $build_virt $target_os $target_build"
      coreos_build $build_virt $target_os $target_build
    elif [[ $builder == "veewee" ]]; then
      squawk 2 " Executing vee wee build..."
      # veewee_build 
      echo 'VeeWee support not built yet :('
      exit 1
    else
      echo 'builder not recognized'
      exit 1
    fi
    exit 0
  elif [[ $RAISON == "node_join" ]]; then
    if [[ $print_help == "true" ]]; then
      node_usage
      exit 1
    fi
    if [[ -z "$node_join_name" ]]; then
      echo 'you must specify the --node-join-name option'
      exit 1
    fi
    if [[ -z "$node_join_ip" ]]; then
      echo 'you must specify the --node-join-ip option'
      exit 1
    fi
    if [[ -z "$node_join_user" ]]; then
      echo 'you must specify the --node-join-user option'
      exit 1
    fi
    if [[ -z "$node_join_port" ]]; then
      echo 'you must specify the --node-join-port option'
      exit 1
    fi
    if [[ -z "$node_join_role" ]]; then
      echo 'you must specify the --node-join-role option'
      exit 1
    fi
    if [[ $node_join_role == "node" ]]; then
      squawk 2 " Executing node join..."
      DO_NODE_JOIN=true
      node_join $node_join_name $node_join_ip $node_join_user $node_join_port
    elif [[ $node_join_role == "master" ]]; then
      squawk 2 " Executing master join..."
      DO_MASTER_JOIN=true
      master_join $node_join_name $node_join_ip $node_join_user $node_join_port
    fi
    exit 0
  elif [[ $RAISON == "true" ]]; then
	  squawk 8 'passthru'
  else
    horizontal_rule
    echo "Command \"$RAISON\" unknown!!! printing usage."
    horizontal_rule
    sleep 2
    usage
    exit 1
  fi

  if [[ $print_help == "true" ]]; then
    usage
    exit 1
  fi

  if [[ $DO_HOSTS == "true" ]]; then
    write_ansible_hosts
  fi

  if [[ $DO_PREP == "true" ]]; then
    prep
  fi

  if [[ $DO_PING == "true" ]]; then
    if [ "$PARALLEL_JOBS" -gt "1" ] ; then
      ping_in_parallel
    else
      ping
    fi
  fi

  if [[ $DO_APING == "true" ]]; then
    ansible-ping
  fi

  if [[ $DO_SHOW == "true" ]]; then
    read_csv
  fi

  if [[ $DO_INSTALL == "true" ]]; then
    do_install
  fi

  if [[ $DO_CSV == "true" ]]; then
    initialize
  fi

  if [[ $DO_GRAB == "true" ]]; then
    do_grab
  fi

  if [[ $DO_NET == "true" ]]; then
    do_net
  fi

  if [[ $DO_TILLER == "true" ]]; then
    do_tiller
  fi

  if [[ $DO_OPENEBS == "true" ]]; then
    do_openebs
  fi

  exit 0
  # End main block
}

main "$@"
